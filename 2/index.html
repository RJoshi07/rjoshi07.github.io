<!DOCTYPE html>
<html lang="en">
<head>
    <title>My Portfolio</title>
    <link rel="stylesheet" href="../styles.css">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <style>
        /* Ensure Section 3 images are scaled down to fit */
        .image-grid img {
        max-width: 100%;
        height: auto;
        display: block;
        }
        .image-grid.cols-3 {
        display: grid;
        grid-template-columns: repeat(3, 1fr);
        gap: 1rem;
        }
        .image-grid figure {
        margin: 0;
        text-align: center;
        }
        </style>
</head>
<body>

<header>
    <nav>
        <h1>My Portfolio</h1>
        <ul class="nav-links">
            <li><a href="../../index.html">Home</a></li>
            <li class="dropdown">
                <a href="#">Projects â–¾</a>
                <div class="dropdown-content">
                    <a href="../0/index.html">Project 0</a>
                    <a href="../1/index.html">Project 1</a>
                </div>
            </li>
        </ul>
    </nav>
</header>

<main>
    <h1>Project 1</h1>
    <section class="project-section">
        <h2>1.1 Convolutions From Scratch!</h2>
        <p>
            In this section I implemented the 2D Convolution Function with 4 loops, and then with 2 loops. The following the results of those, as well as the reuslt of scipy.signal.conv2d. I convolved an image of myself with a 9 x 9 box filter. 
        </p>
        <br>
        <pre><code>
            def convolve_4_loops(img, filter):
                filter = filter[::-1, ::-1]
                pad_w = filter.shape[0]//2
                pad_h = filter.shape[1]//2
                img = np.pad(img, pad_width=((pad_w, pad_w), (pad_h, pad_h)), mode='constant', constant_values=0)

                output_r = img.shape[0] - filter.shape[0] + 1
                output_c = img.shape[1] - filter.shape[1] + 1


                output = np.zeros((output_r, output_c))
                for start_r in range(output_r):
                    for start_c in range(output_c):
                        dot_prod = 0
                        for r in range(filter.shape[0]):
                            for c in range(filter.shape[1]):
                                dot_prod += filter[r][c] * img[start_r + r][start_c + c]
                        output[start_r][start_c] = dot_prod
                return output


            def convolve_2_loops(img, filter, pad = 0):
                filter = filter[::-1, ::-1]
                pad_w = filter.shape[0]//2
                pad_h = filter.shape[1]//2
                img = np.pad(img, pad_width=((pad_w, pad_w), (pad_h, pad_h)), mode='constant', constant_values=0)
                
                output_r = img.shape[0] - filter.shape[0] + 1
                output_c = img.shape[1] - filter.shape[1] + 1


                output = np.zeros((output_r, output_c))
                for start_r in range(output_r):
                    for start_c in range(output_c):
                        dot_prod = np.sum(filter * img[start_r:start_r+filter.shape[0], start_c:start_c+filter.shape[1]])
                        output[start_r][start_c] = dot_prod
                return output
        </code></pre>
        <div class="image-row">
            <figure>
                <img src="../2/me_box_1.png" alt="Photo 3">
                <figcaption>
                    <span class="main-caption">4 Loops</span><br>
                    <span class="sub-caption">Runtime: 2m 32.3s</span>
                </figcaption>
            </figure>
            <figure>
                <img src="../2/me_box_2.png" alt="Photo 3">
                <figcaption>
                    <span class="main-caption">2 Loops</span><br>
                    <span class="sub-caption">Runtime: 15.2s</span>
                </figcaption>
            </figure>
            <figure>
                <img src="../2/me_box_3.png" alt="Photo 3">
                <figcaption>
                    <span class="main-caption">SciPy</span><br>
                    <span class="sub-caption">Runtime: 0.6s</span>
                </figcaption>
            </figure>
        </div>
        <br>
        <p>
            For padding, I handled it the same way SciPy does when the mode = "same" (i.e. the output should be the same size as the input). This means, I calculated the horizontal padding as (P-1)/2 and the vertical padding as (Q-1)/2. This ensures that the output is the same size as the first image I pass in. 

            For runtime, I noticed that the runtime of my method with 4 loops is much slower than my 2 loops method, which is slightly slower than the SciPy method. This makes sense, because using NumPy for some of the matrix calculations is sure to be faster, since it can parallelize many of the operations, and SciPy's built-in function is sure to be optimized. 
        </p>

        <br>
        <h3>Convolving With Different Filters</h3>
        <div class="image-row">
            <figure>
                <img src="../2/me_box_1.png" alt="Photo 3">
                <figcaption>
                    <span class="main-caption">9 x 9 Box Filter</span><br>
                </figcaption>
            </figure>
            <figure>
                <img src="../2/me_dx.png" alt="Photo 3">
                <figcaption>
                    <span class="main-caption">Dx</span><br>
                </figcaption>
            </figure>
            <figure>
                <img src="../2/me_dy.png" alt="Photo 3">
                <figcaption>
                    <span class="main-caption">Dy</span><br>
                </figcaption>
            </figure>
        </div>
    </section>

    <section class="project-section">
        <h2>1.2 Finite Difference Operator</h2>
        <p>
            For this section, I convolved the cameraman image with the Dx and Dy filters and used that to compute the gradient. From there, I played around with a cutoff to produce a relatively clean image of the cameraman edges. I was looking for a good balance of reduced noise (which I especially saw in the form of dots towards the bottom of the image) and a clear image of the cameraman (making the threshold too large resulted in the edges breaking and not forming a clear picture).
        </p>
    </section>

    <section class="project-section">
        <h2>Larger Images</h2>
        <div class="image-grid cols-3">
            <figure>
                <img src="../2/cameraman.png" alt="cameraman">
                <figcaption>
                    <span class="main-caption">Original Image</span><br>
                </figcaption>
            </figure>
            <figure>
                <img src="../2/cameraman_dx.png" alt="cameraman_dx">
                <figcaption>
                    <span class="main-caption">Convolved with Dx</span><br>
                </figcaption>
            </figure>
            <figure>
                <img src="../2/cameraman_dy.png" alt="cameraman_dy">
                <figcaption>
                    <span class="main-caption">Convolved with Dy</span><br>
                </figcaption>
            </figure>

            <figure>
                <img src="../2/cameraman_gradient.png" alt="cameraman_gradient">
                <figcaption>
                    <span class="main-caption">Gradient</span><br>
                </figcaption>
            </figure>
            <figure>
                <img src="../2/cameraman_edges.png" alt="cameraman_edges">
                <figcaption>
                    <span class="main-caption">Edges</span><br>
                </figcaption>
            </figure>
        </div>
    </section>

    <section class="project-section">
        <h2>1.3 Derivative of Gaussian (DoG) Filter</h2>
        <p>
            In this section, I blurred the cameraman image with a Gaussian filter before repeating the process from 1.2. I notice that this time, the gradient appears a little thicker, which allows the final step to capture the edges much better without picking up noise (which kind of goes away due to blurring)
        </p>
    </section>

    <section class="project-section">
        <h2></h2>
        <div class="image-row">
            <figure>
                <img src="../2/cameraman_blurred.png" alt="cameraman_blurred">
                <figcaption>
                    <span class="main-caption">Blurred Image</span><br>
                </figcaption>
            </figure>
            <figure>
                <img src="../2/cameraman_new_gradient_1.png" alt="cameraman_new_gradient_1">
                <figcaption>
                    <span class="main-caption">Gradient</span><br>
                </figcaption>
            </figure>
            <figure>
                <img src="../2/cameraman_new_edges_1.png" alt="cameraman_new_edges_1">
                <figcaption>
                    <span class="main-caption">Edges</span><br>
                </figcaption>
            </figure>
        </div>
    </section>

    <section class="project-section">
        <p>
            I then repeated the same process except this time, instead of blurring the image itself with the Gaussian, I convolved the Gaussian itself with Dx and Dy before convoling the image with the Gaussian. This produced the same result. 
        </p>
    </section>

    <section class="project-section">
        <h2></h2>
        <div class="image-row">
            <figure>
                <img src="../2/cameraman_new_gradient_2.png" alt="cameraman_new_gradient_2">
                <figcaption>
                    <span class="main-caption">Gradient using DoG</span><br>
                </figcaption>
            </figure>
            <figure>
                <img src="../2/cameraman_new_edges_2.png" alt="cameraman_new_edges_2">
                <figcaption>
                    <span class="main-caption">Edges using DoG</span><br>
                </figcaption>
            </figure>
        </div>
    </section>

    <!-- Section 4: another block of text -->
    <section class="project-section">
        <h2>2. Image Pyramids for Larger Images</h2>
        <p>
            On larger images, I found my original algorithm taking much longer, especially since I needed to calculate larger offsets for these images as well. Therefore, I attempted to speed up the alignment process by using image pyramids. To do this, I started by scaling down my image by a factor of 16. Then, I ran the same process as before, calculating the score for different offsets, this time from -10 to +10. Once i found the optimal offset on the coarse images, I rolled the original images by that amount of displacement and scaled it down by a factor of 8 next. I then repeated the same process again and again, scaling my image down by a smaller factor each time, until I came back up to the original image. I also searched a smaller and smaller window of displacement each time, since I didn't have to look as far each time. 
        </p>
        <p>
            For the score calculation, I found NCC working slightly better for this part, so I opted to using that instead. One other issue i ran into was that some of my images still weren't aligning that well, particularly the Emir image. To combat this, I thought that perhaps rolling the image each time before calculating the score again on the next level up the pyramid might be altering the score, since the edges which eand up on the opposite side may skew the score. Therefore, when calculating the score, I cropped off 5% from each edge of the image, just to confirm that we are only calcuating the score off of the parts of image we are focused on aligning. 
        </p>
    </section>
</main>

<!-- Optional minimal helper styles if your stylesheet lacks grid classes
     You can paste these into styles.css if needed:

.image-grid { display: grid; gap: 1rem; }
.image-grid.cols-3 { grid-template-columns: repeat(3, 1fr); }
.image-row { display: flex; gap: 1rem; flex-wrap: wrap; }
.image-row figure, .image-grid figure { margin: 0; }
img { max-width: 100%; height: auto; display: block; }

-->

</body>
</html>